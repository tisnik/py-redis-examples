<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Databáze Redis (nejenom) pro vývojáře používající Python</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Databáze Redis (nejenom) pro vývojáře používající Python</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se seznámíme s nerelační databází Redis, kterou je možné díky její flexibilitě využít k mnoha účelům, například pro implementaci vyrovnávací paměti, ve funkci distribuované key-value databáze, popř. pro implementaci systémů založených na frontách zpráv.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Databáze Redis (nejenom) pro vývojáře používající Python</a></p>
<p><a href="#k02">2. Instalace Redisu</a></p>
<p><a href="#k03">3. Konfigurace vhodná pro první seznámení s&nbsp;Redisem</a></p>
<p><a href="#k04">4. Spuštění Redisu a první experimenty se systémem</a></p>
<p><a href="#k05">5. Perzistentní uložení databáze</a></p>
<p><a href="#k06">6. AOF &ndash; Append Only File</a></p>
<p><a href="#k07">7. Nastavení doby životnosti dat</a></p>
<p><a href="#k08">8. Podporované datové typy, s&nbsp;nimiž Redis pracuje</a></p>
<p><a href="#k09">9. Práce s&nbsp;řetězci uloženými do databáze</a></p>
<p><a href="#k10">10. Seznamy</a></p>
<p><a href="#k11">11. Množiny</a></p>
<p><a href="#k12">12. Množinové operace</a></p>
<p><a href="#k13">13. Mapy (asociativní pole)</a></p>
<p><a href="#k14">14. Množiny s&nbsp;ohodnocenými prvky (uspořádané množiny)</a></p>
<p><a href="#k15">15. Další operace s&nbsp;uspořádanými množinami</a></p>
<p><a href="#k16">16. Transakce</a></p>
<p><a href="#k17">17. Použití Redisu z&nbsp;Pythonu</a></p>
<p><a href="#k18">18. Vybrané operace poskytované knihovnou <strong>redis</strong></a></p>
<p><a href="#k19">19. Využití &bdquo;pipeline&ldquo; pro sloučení většího množství příkazů do jediného požadavku</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Databáze Redis (nejenom) pro vývojáře používající Python</h2>

<p>Databáze <i>Redis</i> (<i>REmote DIctionary Server</i>) patří do rozsáhlé a
nehomogenní skupiny nerelačních databází. Konkrétně se jedná o databázi typu
key-value, což znamená, že hodnoty ukládané do databáze je možné jednoznačně
identifikovat (najít, smazat atd.) na základě klíče, který je reprezentován
řetězcem. Podobných databází samozřejmě existuje celá řada; za zmínku stojí
především <i>Berkeley DB</i>, dále pak <i>MemcacheDB</i>, <i>Dynamo</i> či
<i>InfinityDB</i>. Dnes popisovaná databáze <i>Redis</i> může být pro vývojáře
zajímavá a užitečná zejména z&nbsp;toho důvodu, že se jedná o velmi flexibilní
systém, který lze škálovat nejenom &bdquo;nahoru&ldquo; (distribuované systémy
se shardingem a/nebo replikací), ale i &bdquo;dolů&ldquo; (jednoduše
nastavitelné datové odkladiště pro jednouživatelskou aplikaci).</p>

<p>Na jedné straně je možné <i>Redis</i> provozovat na jediném stroji
s&nbsp;tím, že data budou uložena pouze v&nbsp;operační paměti, na straně druhé
je však možné relativně snadno nakonfigurovat <i>Redis</i> takovým způsobem, že
data budou rozložena mezi více strojů (<i>sharding</i>), popř.&nbsp;se použije
architektura typu master-slave, kdy bude <i>Redis</i> data replikovat na pozadí
mezi uzlem typu master a uzly typu slave (se všemi z&nbsp;toho vyplývajícími
důsledky).</p>

<p>Díky této flexibilitě je možné systém <i>Redis</i> v&nbsp;praxi využít mnoha
různými způsoby. Používá se například ve formě vyrovnávací paměti
(<i>cache</i>), přičemž je dokonce možné <a href="#k07">specifikovat dobu
života jednotlivých údajů</a>, takže mazání starších položek nemusí být řešeno
přímo v&nbsp;aplikaci (životnost údajů lze snadno obnovit, což se hodí
například při ukládání informací o <i>session/sezení</i> u webových aplikací).
Ovšem <i>Redis</i> můžeme použít i jako plnohodnotnou key-value databázi
s&nbsp;tím, že data budou na pozadí ukládána na nevolatilní paměť (typicky na
pevný disk či dnes spíše na SSD), což znamená, že údaje přežijí restart Redisu,
pád počítače či systému atd. K&nbsp;dispozici mají vývojáři dvě základní
strategie ukládání dat do nevolatilní paměti, které lze dokonce použít
současně, o čemž se ve stručnosti zmíníme <a href="#k05">v&nbsp;páté</a> a <a
href="#k06">šesté kapitole</a>. V&nbsp;případě potřeby je možné realizovat i
systém s&nbsp;transakcemi popř.&nbsp;využít některé atomické operace, které
<i>Redis</i> podporuje už ve své základní sadě příkazů.</p>

<p>Z&nbsp;praktického hlediska je užitečné, že k&nbsp;<i>Redisu</i>, který je
již při základní instalaci vybaven klientem ovládaným z&nbsp;příkazové řádky,
je možné přistupovat z&nbsp;mnoha programovacích jazyků: na stránce <a
href="https://redis.io/clients">https://redis.io/clients</a> jsou vypsány
informace o rozhraních k&nbsp;padesáti (!) jazykům, samozřejmě včetně populární
pětice C, C++, Java, Python a Go. Navíc je možné od verze 2.6 dokonce využít i
podporu pro přímé spouštění příkazů Redisu ze skriptů napsaných <a
href="https://www.root.cz/serialy/programovaci-jazyk-lua/">v&nbsp;programovacím
jazyce Lua</a>, který se skutečně velmi dobře hodí pro <a
href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">skriptování
aplikací</a>. Důležité přitom je, že skripty lze nahrát přímo do serveru Redisu
a spustit je až ve chvíli, kdy jsou skutečně zapotřebí. V&nbsp;dnešním článku
se však zaměříme především na použití Redisu přímo ze standardního klienta
<strong>redis-cli</strong> a posléze z&nbsp;Pythonu.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace Redisu</h2>

<p>Před otestováním možností Redisu je samozřejmě nutné tento nástroj
nainstalovat. Vzhledem k&nbsp;tomu, že se jedná o (na dnešní poměry) vlastně
velmi malý projekt, je instalace prakticky okamžitá. Jen pro ukázku se
podívejme na instalaci na Fedoře 27 s&nbsp;využitím nástroje
<strong>dnf</strong>:</p>

<pre>
$ <strong>sudo dnf install redis</strong>
&nbsp;
Last metadata expiration check: 0:15:30 ago on Wed 24 Oct 2018, 22:50:11 CEST.
Dependencies resolved.
================================================================================
 Package           Arch            Version               Repository        Size
================================================================================
Installing:
 redis             x86_64          4.0.9-1.fc27          updates          580 k
Installing dependencies:
 jemalloc          x86_64          4.5.0-5.fc27          updates          210 k
&nbsp;
Transaction Summary
================================================================================
Install  2 Packages
&nbsp;
Total download size: 790 k
Installed size: 2.0 M
Is this ok [y/N]:
</pre>

<p>Samotný průběh instalace:</p>

<pre>
Downloading Packages:
(1/2): jemalloc-4.5.0-5.fc27.x86_64.rpm         1.0 MB/s | 210 kB     00:00    
(2/2): redis-4.0.9-1.fc27.x86_64.rpm            2.3 MB/s | 580 kB     00:00    
--------------------------------------------------------------------------------
Total                                           1.0 MB/s | 790 kB     00:00     
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                        1/1 
  Installing       : jemalloc-4.5.0-5.fc27.x86_64                           1/2 
  Running scriptlet: jemalloc-4.5.0-5.fc27.x86_64                           1/2 
  Running scriptlet: redis-4.0.9-1.fc27.x86_64                              2/2 
  Installing       : redis-4.0.9-1.fc27.x86_64                              2/2 
  Running scriptlet: redis-4.0.9-1.fc27.x86_64                              2/2 
Running as unit: run-r389424a3db894d8e83bddf2d54cd6d4e.service
  Verifying        : redis-4.0.9-1.fc27.x86_64                              1/2 
  Verifying        : jemalloc-4.5.0-5.fc27.x86_64                           2/2 
&nbsp;
Installed:
  redis.x86_64 4.0.9-1.fc27             jemalloc.x86_64 4.5.0-5.fc27            
&nbsp;
Complete!
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se nainstalovala verze
Redisu 4.0.9. Ve skutečnosti je však k&nbsp;dispozici i novější Redis 5.0. Tato
nová verze podporuje některé příkazy, které ve verzi 4.0.x nenalezneme. Týká se
to například příkazů <strong>ZPOPMIN</strong> a <strong>ZPOPMAX</strong>
používaných při práci s&nbsp;množinami, do nichž jsou uloženy ohodnocené prvky
(resp.&nbsp;přesněji řečeno prvky s&nbsp;přiřazeným skóre). Nicméně všechny
funkce, které si popíšeme v&nbsp;dnešním článku, budou funkční jak na verzích
4.0.x, tak i na verzi 5.0.</div></p>

<p>Na systémech založených na Debianu (včetně Ubuntu) lze pro instalaci použít
příkaz:</p>

<pre>
$ <strong>apt-get install redis-server</strong>
</pre>

<p>Pokud budete potřebovat použít nejnovější verzi Redisu, můžete si ho sami
přeložit. Postup je jednoduchý (mj.&nbsp;i díky minimálním závislostem na
dalších knihovnách) a je podrobně popsán na stránce <a
href="https://redis.io/topics/quickstart">https://redis.io/topics/quickstart</a>.</p>

<p>Po instalaci se můžeme přesvědčit, že je skutečně k&nbsp;dispozici
spustitelný soubor s&nbsp;implementací serveru i řádkového klienta:</p>

<pre>
$ <strong>whereis -b redis-cli</strong>
redis-cli: /usr/bin/redis-cli
&nbsp;
$ <strong>whereis -b redis-server</strong>
redis-server: /usr/bin/redis-server
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Konfigurace vhodná pro první seznámení s&nbsp;Redisem</h2>

<p>Databázový server <i>Redis</i> je sice možné spustit jako službu, ale pro
otestování jeho základní funkcionality bude jednodušší a především bezpečnější
spustit tuto aplikaci pouze lokálně &ndash; Redis sice bude stále pracovat ve
funkci serveru, ale bude akceptovat pouze požadavky o připojení, které přichází
ze stejného počítače a nikoli z&nbsp;okolních strojů. Nejprve si vytvoříme
adresář, v&nbsp;němž bude uložena jak konfigurace, tak všechny vytvářené datové
soubory. Tento adresář pojmenovaný jednoduše &bdquo;redis&ldquo; vytvoříme
přímo v&nbsp;domácím adresáři právě přihlášeného uživatele a následně se do něj
přepneme:</p>

<pre>
$ <strong>mkdir redis</strong>
$ <strong>cd redis</strong>
</pre>

<p>Následně přímo v&nbsp;tomto adresáři vytvoříme konfigurační soubor nazvaný
<strong>redis.conf</strong>. Můžeme se přitom inspirovat souborem
<strong>/etc/redis/redis.conf</strong> (Debian)
popř.&nbsp;<strong>/etc/redis.conf</strong> (Fedora, RHEL, CentOS), který je
však poměrně rozsáhlý, protože kromě vlastních konfiguračních voleb obsahuje i
podrobné informace o významu jednotlivých konfiguračních voleb. Tento soubor je
taktéž dostupný na internetu na adrese <a
href="https://raw.githubusercontent.com/antirez/redis/4.0/redis.conf">https://raw.githubusercontent.com/antirez/redis/4.0/redis.conf</a>.</p>

<p>Následuje výpis obsahu konfiguračního souboru, který je připraven pro
lokální spuštění Redisu, bez nebezpečí, že se k&nbsp;běžícímu serveru připojí
případný útočník. Důležité volby jsou zvýrazněny a některé z&nbsp;nich budou
popsány na konci kapitoly. Pokud se vám soubor nechce kopírovat, naleznete ho
na adrese <a
href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>:</p>

<pre>
<strong>bind 127.0.0.1</strong>
<strong>protected-mode yes</strong>
port 6379
tcp-backlog 511
timeout 0
tcp-keepalive 300
daemonize no
supervised no
pidfile /var/run/redis_6379.pid
loglevel notice
<strong>logfile redis.log</strong>
databases 16
always-show-logo yes
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
<strong>dir .</strong>
slave-serve-stale-data yes
slave-read-only yes
repl-diskless-sync no
repl-diskless-sync-delay 5
repl-disable-tcp-nodelay no
slave-priority 100
lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
slave-lazy-flush no
appendonly yes
<strong>appendfilename "appendonly.aof"</strong>
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
aof-load-truncated yes
aof-use-rdb-preamble no
lua-time-limit 5000
slowlog-log-slower-than 10000
slowlog-max-len 128
latency-monitor-threshold 0
notify-keyspace-events ""
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-size -2
list-compress-depth 0
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
hll-sparse-max-bytes 3000
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
aof-rewrite-incremental-fsync yes
</pre>

<p>Popišme si nyní ve stručnosti zvýrazněné konfigurační volby:</p>

<table>
<tr><th>Volba</th><th>Význam</th></tr>
<tr><td>bind 127.0.0.1</td><td>seznam síťových rozhraní, na kterých bude Redis přijímat požadavky (zde explicitně povolujeme jen loopback)</td></tr>
<tr><td>protected-mode yes</td><td>pokud zapomenete na předchozí volbu a nezadáte heslo, zapne se režim přijímaní lokálních požadavků</td></tr>
<tr><td>logfile redis.log</td><td>jméno logovacího souboru, zde uvedeno bez adresáře: bude lokální (kde spustíme server)</td></tr>
<tr><td>dir .</td><td>adresář, do kterého se budou ukládat soubory obsahující databázi</td></tr>
<tr><td>appendfilename "appendonly.aof"</td><td>jméno a umístění takzvaného &bdquo;append only file&ldquo; popsaného níže</td></tr>
</table>

<p>Takto nastavený Redis bude ukládat prakticky všechny své soubory do
aktuálního adresáře. Jediným souborem vytvářeným mimo tento adresář bude soubor
<a href="https://en.wikipedia.org/wiki/Process_identifier">s&nbsp;PID</a>
běžícího Redisu, který nalezneme
v&nbsp;<strong>/var/run/redis_6379.pid</strong>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Spuštění Redisu a první experimenty se systémem</h2>

<p>Nejprve spustíme serverovou část Redisu, a to přímo z&nbsp;adresáře
<strong>~/redis</strong>, protože právě zde máme uložen výše popsaný
konfigurační soubor &bdquo;redis.conf&ldquo;</p>

<pre>
$ <strong>pwd</strong>
/home/tester/redis
&nbsp;
$ <strong>redis-server redis.conf </strong>
</pre>

<p>Na druhém terminálu pak již můžeme spustit klienta Redisu, který uživatelům
nabízí interaktivní příkazový řádek:</p>

<pre>
$ <strong>redis-cli</strong>
127.0.0.1:6379&gt;
</pre>

<p>Příkazem &bdquo;ping&ldquo; můžeme otestovat, jestli se klient připojí
k&nbsp;serveru a zda od něj dokáže získávat odpovědi:</p>

<pre>
127.0.0.1:6379&gt; <strong>ping</strong>
PONG
127.0.0.1:6379&gt; <strong>ping test</strong>
"test"
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dokumentaci jsou všechny příkazy
psány velkými písmeny, ovšem v&nbsp;interaktivním shellu můžete používat i
písmena malá. Všechny tři následující příkazy jsou tedy z&nbsp;pohledu Redisu
totožné:</div></p>

<pre>
127.0.0.1:6379&gt; <strong>ping</strong>
PONG
127.0.0.1:6379&gt; <strong>PinG</strong>
PONG
127.0.0.1:6379&gt; <strong>PING</strong>
PONG
</pre>

<p>Uložení hodnoty do databáze se provádí příkazem <strong>set</strong>,
kterému se předá klíč (řetězec) a hodnota (taktéž řetězec):</p>

<pre>
127.0.0.1:6379&gt; <strong>set answer 42</strong>
OK
</pre>

<p>Opakem operace <strong>set</strong> je přečtení hodnoty příkazem
<strong>get</strong>. Povšimněte si, že se skutečně vrací řetězec a pokud
hodnota neexistuje (resp.&nbsp;přesněji řečeno pokud neexistuje dvojice
klíč-hodnota), vrátí se hodnota <strong>nil</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>get answer</strong>
"42"
127.0.0.1:6379&gt; <strong>get foobar</strong>
(nil)
</pre>

<p>Vzhledem k&nbsp;tomu, že klíčem může být jakýkoli řetězec, můžeme se setkat
s&nbsp;tím, že ve jménech klíčů je vyjádřena nějaká hierarchie dat. Používají
se například tečky, dvojtečky nebo lomítka:</p>

<pre>
127.0.0.1:6379&gt; <strong>set users:root "Administrator"</strong>
OK
127.0.0.1:6379&gt; <strong>set users:pavel "Tester"</strong>
OK
127.0.0.1:6379&gt; <strong>set users:petr "Developer"</strong>
OK
127.0.0.1:6379&gt; <strong>get users:petr</strong>
"Developer"
127.0.0.1:6379&gt; <strong>set users:petr "DevOps"</strong>
OK
127.0.0.1:6379&gt; <strong>get users:petr</strong>
"DevOps"
</pre>

<p>Příkazem <strong>setnx</strong> taktéž do databáze ukládáme dvojici
klíč-hodnota, ale pouze v&nbsp;případě, že daný klíč ještě neexistuje. Pokud
klíč existuje, není hodnota přepsána:</p>

<pre>
127.0.0.1:6379&gt; <strong>setnx users:petr "Developer again"</strong>
(integer) 0
127.0.0.1:6379&gt; <strong>get users:petr</strong>
"DevOps"
127.0.0.1:6379&gt; <strong>setnx users:lukas "New Developer"</strong>
(integer) 1
127.0.0.1:6379&gt; <strong>get users:lukas</strong>
"New Developer"
</pre>

<p>Často se setkáme s&nbsp;tím, že se současně načítá větší množství dvojic
klíč-hodnota příkazem <strong>mget</strong>. Eliminuje se tím počet zpráv
předávaných serveru, což se pozitivně projeví na plně zatíženém systému:</p>

<pre>
127.0.0.1:6379&gt; <strong>mget users:root users:pavel users:petr users:zdenek</strong>
1) "Administrator"
2) "Tester"
3) "DevOps"
4) (nil)
</pre>

<p>Řádkový klient obsahuje i vestavěnou nápovědu:</p>

<pre>
127.0.0.1:6379&gt; <strong>help</strong>
redis-cli 4.0.9
To get help about Redis commands type:
      "help @&lt;group&gt;" to get a list of commands in &lt;group&gt;
      "help &lt;command&gt;" for help on &lt;command&gt;
      "help &lt;tab&gt;" to get a list of possible help topics
      "quit" to exit
&nbsp;
To set redis-cli preferences:
      ":set hints" enable online hints
      ":set nohints" disable online hints
Set your preferences in ~/.redisclirc
</pre>

<p>Po ukončení interaktivního shellu můžeme ukončit i běh samotného serveru
Redisu, například stiskem Ctrl+C v&nbsp;terminálu, kde server běží,
popř.&nbsp;příkazem <strong>shutdown</strong> zadaným z&nbsp;řádkového
klienta:</p>

<pre>
127.0.0.1:6379&gt; <strong>shutdown</strong>
not connected&gt;
</pre>

<p>Nyní by se v&nbsp;aktuálním adresáři <strong>~/redis/</strong> měla nacházet
čtveřice souborů:</p>

<pre>
$ <strong>ls -1</strong>
appendonly.aof
dump.rdb
redis.conf
redis.log
</pre>

<p>V&nbsp;dalších kapitolách si vysvětlíme především význam souboru
<strong>dump.rdb</strong> a <strong>appendonly.aof</strong>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Perzistentní uložení databáze</h2>

<p>Databázi Redis je možné nakonfigurovat mnoha různými způsoby. Pro
jednoduchost předpokládejme, že celá databáze bude provozována na jediném
stroji, tj.&nbsp;nebudeme používat ani horizontální škálování ani replikace.
Takto nakonfigurovaná databáze může být uložena buď pouze v&nbsp;operační
paměti (typické použití &ndash; cache), nebo ji lze ukládat i do nevolatilní
paměti (pevný disk, SSD, ...). Existují čtyři prakticky používané
kombinace:</p>

<ol>
<li>Databáze je uložena jen v RAM</li>
<li>Použití kombinace RAM + soubory RDB</li>
<li>Použití kombinace RAM + soubory AOF</li>
<li>Použití kombinace RAM + soubory RDB i AOF</li>
</ol>

<p>Na discích, resp.&nbsp;obecně na paměťových médiích, je databáze ukládána do
souborů s&nbsp;koncovkou <strong>.rdb</strong>. Jedná se o binární soubory,
které jsou navrženy takovým způsobem, aby práce s&nbsp;nimi byla velmi rychlá.
V&nbsp;případě potřeby se používá <a
href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">komprimace
LZW</a> pro zmenšení velikosti těchto souborů. Interně je před každým objektem
uloženým v&nbsp;tomto souboru specifikována i velikost objektu, což
zjednodušuje načítání <strong>.rdb</strong> zpět do operační paměti. Na konci
souboru je navíc (v&nbsp;závislosti na konfiguraci) uložen 64bitový kontrolní
součet, který je možné použít pro jednoduchou kontrolu konzistence dat.</p>

<p>Mimochodem, konzistenci samotného souboru s&nbsp;obrazem databáze je možné
zkontrolovat příkazem <strong>redis-check-rdb</strong>:</p>

<pre>
$ <strong>redis-check-rdb dump.rdb </strong>
&nbsp;
[offset 0] Checking RDB file dump.rdb
[offset 26] AUX FIELD redis-ver = '4.0.9'
[offset 40] AUX FIELD redis-bits = '64'
[offset 52] AUX FIELD ctime = '1541800518'
[offset 67] AUX FIELD used-mem = '513184'
[offset 83] AUX FIELD aof-preamble = '0'
[offset 85] Selecting DB ID 0
[offset 455] Checksum OK
[offset 455] \o/ RDB looks OK! \o/
[info] 18 keys read
[info] 0 expires
[info] 0 already expired
</pre>

<p>Jak se vlastně soubory <strong>RDB</strong> vytváří? Frekvence tvorby těchto
souborů je plně konfigurovatelná administrátorem, který například může
specifikovat, že se tyto soubory budou obnovovat každých pět minut, po zápisu
deseti prvků atd. Samotný zápis probíhá do nového souboru a teprve po provedení
celého zápisu (a provedení <strong>flush</strong>) se provede přejmenování
souboru, což je &ndash; minimálně v&nbsp;Linuxu &ndash; atomická operace. Vždy
tedy budeme mít k&nbsp;dispozici buď dvojici starý_RDB +
potenciálně_neúplný_nový_RDB nebo nový_RDB; nemělo by dojít k&nbsp;situaci, kdy
je starý RDB vymazán a nový ještě není konzistentní.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. AOF &ndash; Append Only File</h2>

<p>Víme již, že kromě obrazu databáze ukládaného do souborů RDB, je možné
použít takzvané <i>Append Only File(s)</i> neboli <i>AOF</i>. Jedná se o
textové a tudíž i snadno čitelné textové soubory, do nichž se postupně ukládají
všechny příkazy, které modifikují obsah databáze (v&nbsp;praxi to znamená, že
zde například nenalezneme příkazy GET). Při opětovném startu Redisu je tedy
možné, aby server tento soubor &bdquo;přehrál&ldquo; (vykonal všechny
v&nbsp;něm uložené příkazy) a databázi tak obnovil. Použití souborů <i>AOF</i>
je možné zakázat či povolit a při jejich povolení je navíc možné specifikovat,
jak často se budou provádět zápisy příkazů. Platí jednoduché a pochopitelné
pravidlo &ndash; čím častěji budeme chtít provádět zápisy (skutečné zápisy
následované příkazem <strong>flush</strong>), tím více klíčů se nám podaří
obnovit, ovšem zápisy <i>AOF</i> na druhou stranu zpomalí všechny zápisy do
databáze (čtení není nijak ovlivněno). Záleží tedy na administrátorech databáze
a samozřejmě též na aplikaci, které databázi používá, kolik potenciálně
ztracených dat je možné tolerovat (údaje z&nbsp;poslední minuty? poslední dva
zápisy? atd.).</p>

<p><div class="rs-tip-major">Poznámka: označení <i>Append Only File</i> je
pravdivé a přiléhavé, protože se do těchto souborů skutečně pouze přidávají
řádky na konec. Nikdy se neprovede <strong>seek</strong> a nemělo by tedy dojít
k&nbsp;poškození již zapsaných informací. Pokud je poškozen konec souboru, což
může nastat při nečekaném pádu celého systému (výpadek elektřiny apod.),
nepředstavuje to pro Redis katastrofální problém &ndash; soubor se jednoduše
&bdquo;přehraje&ldquo; až do okamžiku, kdy jsou detekovány poškozené údaje a na
tomto místě obnova databáze skončí.</div></p>

<p>Pokud se podíváme do souboru nazvaného <strong>appendonly.aof</strong> (viz
<a href="#k03">třetí kapitolu</a> s&nbsp;konfigurací, kde jsme specifikovali
umístění tohoto souboru do aktuálního adresáře), měli bychom vidět následující
obsah, který odpovídá operacím, které jsme v&nbsp;databázi provedli. Samozřejmě
zůstává zachováno pořadí těchto operací. Je tomu tak z&nbsp;toho důvodu, že
&bdquo;přehráním&ldquo; AOF souboru bychom měli dostat přesný obraz
databáze:</p>

<pre>
*2
$6
SELECT
$1
0
*3
$3
set
$6
answer
$2
42
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti můžeme v&nbsp;AOF najít
odlišné příkazy, než ty, které byly zadány uživatelem. To se může týkat
například dále popsaného příkazu <strong>INCR</strong> atd. Výsledek
(z&nbsp;pohledu obsahu databáze) však bude stejný.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nastavení doby životnosti dat</h2>

<p>V&nbsp;případě, že se systém <i>Redis</i> používá pro implementaci
vyrovnávací paměti, je možné využít jeho další užitečnou funkci &ndash; u všech
záznamů je totiž možné specifikovat dobu jejich životnosti (<i>TTL &ndash; Time
To Live</i>). K&nbsp;tomuto účelu se používá několik příkazů, zejména pak:</p>

<table>
<tr><th>Příkaz</th><th>Význam</th></tr>
<tr><td>setex</td><td>vytvoření záznamu + nastavení jeho životnosti v&nbsp;sekundách</td></tr>
<tr><td>psetex</td><td>vytvoření záznamu + nastavení jeho životnosti v&nbsp;milisekundách</td></tr>
<tr><td>expire</td><td>nastavení životnosti existujícího záznamu v&nbsp;sekundách</td></tr>
<tr><td>pexpire</td><td>nastavení životnosti existujícího záznamu v&nbsp;milisekundách</td></tr>
</table>

<p>Podívejme se nyní na způsob použití příkazu <strong>expire</strong>. Již
v&nbsp;předchozích kapitolách byly do databáze uloženy informace o několika
uživatelích, ale klidně můžeme tyto příkazy zopakovat:</p>

<pre>
127.0.0.1:6379&gt; <strong>set users:root "Administrator"</strong>
OK
127.0.0.1:6379&gt; <strong>set users:pavel "Tester"</strong>
OK
127.0.0.1:6379&gt; <strong>set users:petr "Developer"</strong>
OK
</pre>

<p>Dobu životnosti jednotlivých záznamů lze ovlivnit příkazem
<strong>expire</strong>, přičemž TTL je v&nbsp;nejjednodušším případě nastaveno
v&nbsp;sekundách:</p>

<pre>
127.0.0.1:6379&gt; <strong>expire users:pavel 10</strong>
(integer) 1
127.0.0.1:6379&gt; <strong>expire users:petr 5</strong>
(integer) 1
</pre>

<p>Pokus o načtení čtyř záznamů ihned po provedení předchozích příkazů:</p>

<pre>
127.0.0.1:6379&gt; <strong>mget users:root users:pavel users:petr users:zdenek</strong>
1) "Administrator"
2) "Tester"
3) "DevOps"
4) (nil)
</pre>

<p>Po čtvrtminutě ovšem dostaneme rozdílné výsledky:</p>

<pre>
127.0.0.1:6379&gt; <strong>mget users:root users:pavel users:petr users:zdenek</strong>
1) "Administrator"
2) (nil)
3) (nil)
4) (nil)
</pre>

<p>Aktuální dobu životnosti můžeme zjistit příkazem <strong>ttl</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>expire users:root 20</strong>
(integer) 1
127.0.0.1:6379&gt; <strong>ttl users:root</strong>
(integer) 16
127.0.0.1:6379&gt; <strong>ttl users:root</strong>
(integer) 10
127.0.0.1:6379&gt; <strong>ttl users:root</strong>
(integer) 0
127.0.0.1:6379&gt; <strong>ttl users:root</strong>
(integer) -2
</pre>

<p>Zajímavá je poslední hodnota. Příkaz <strong>ttl</strong> totiž vrací buď
přirozené číslo vyjadřující zbývající životnost, nebo zápornou hodnotu
s&nbsp;tímto významem:</p>

<ul>
<li>-1: klíč existuje, ale nemá přiřazenou životnost (je neomezená)</li>
<li>-2: klíč už neexistuje, takže záznam již byl pravděpodobně odstraněn</li>
</ul>



<p><a name="k08"></a></p>
<h2 id="k08">8. Podporované datové typy, s&nbsp;nimiž Redis pracuje</h2>

<p>Při ukládání a zpracování dat ukládaných do Redisu je možné data
reprezentovat několika datovými typy. Jména jednotlivých typů jsou vypsána
v&nbsp;tabulce pod tímto odstavcem a v&nbsp;navazujících kapitolách si řekneme
o vybraných typech některé bližší informace (zaměřené spíše na jejich praktické
použití):</p>

<table>
<tr><th>Jméno</th><th>Stručná charakteristika</th></tr>
<tr><td>string</td><td>řetězce, které lze ovšem využít i pro práci s&nbsp;celými čísly i čísly s&nbsp;FP</td></tr>
<tr><td>list</td><td>seznamy, ve skutečnosti se s&nbsp;nimi pracuje jako se zásobníkem a frontou</td></tr>
<tr><td>set</td><td>množiny, je zaručena unikátnost prvků</td></tr>
<tr><td>sorted set</td><td>množiny, v&nbsp;nichž jsou jednotlivé prvky ohodnoceny skórem</td></tr>
<tr><td>hash</td><td>mapy (též asociativní pole)</td></tr>
<tr><td>bitmap (bit array)</td><td>pole bitů, interně mapovány na řetězce</td></tr>
<tr><td>HyperLogLogs (HLL)</td><td>datová struktura používaná pro zjištění počtu unikátních prvků (s&nbsp;určitou chybou, ovšem s&nbsp;malou spotřebou paměti)</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Práce s&nbsp;řetězci uloženými do databáze</h2>

<p>Základním datovým typem, který se v&nbsp;Redisu používá, jsou řetězce. Ve
skutečnosti se jedná o sekvenci bajtů známé délky, které nejsou žádným způsobem
interpretovány. Díky tomu, že je délka řetězce uložena ve zvláštním atributu,
nemusí Redis používat například znak s&nbsp;kódem 0 pro ukončení řetězce a
tudíž se i tento znak může bez problému v&nbsp;řetězci vyskytovat. Maximální
délka řetězce je v&nbsp;současné verzi Redisu 512 MB, což v&nbsp;praxi znamená,
že se řetězce mohou použít například pro uložení dokumentů, strukturovaných dat
reprezentovaných ve formátech JSON, XML, YAML atd. atd.</p>

<p>Mezi základní příkazy pro práci s&nbsp;řetězci patří nám již známé příkazu
<strong>set</strong> a <strong>get</strong>. Ovšem řetězce lze i modifikovat
příkazem <strong>append</strong> a můžeme získat délku řetězce pomocí
<strong>strlen</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>set z ""</strong>
OK
127.0.0.1:6379&gt; <strong>append z "Hello"</strong>
(integer) 5
127.0.0.1:6379&gt; <strong>append z " "</strong>
(integer) 6
127.0.0.1:6379&gt; <strong>append z "world!"</strong>
(integer) 12
127.0.0.1:6379&gt; <strong>get z</strong>
"Hello world!"
127.0.0.1:6379&gt; <strong>strlen z</strong>
(integer) 12
</pre>

<p>Zajímavé je, že i když Redis neobsahuje přímou podporu pro datový typ
&bdquo;celé číslo&ldquo;, nabízí svým uživatelům několik operací určených pro
<i>atomickou</i> změnu numerických hodnot reprezentovaných řetězcem
v&nbsp;běžném dekadickém formátu. Pro zvýšení hodnoty o jedničku se používá
operace <strong>INCR</strong>, opakem je pochopitelně funkce
<strong>DECR</strong>. V&nbsp;případě, že budeme potřebovat zvýšit nebo snížit
uloženou hodnotu o krok odlišný od jedničky, je možné pro tento účel použít
operaci pojmenovanou příhodně <strong>INCRBY</strong>. Podívejme se na příklady
(spouštěné přímo z&nbsp;<strong>redis-cli</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>set x 0</strong>
OK
127.0.0.1:6379&gt; <strong>INCR x</strong>
(integer) 1
127.0.0.1:6379&gt; <strong>get x</strong>
"1"
127.0.0.1:6379&gt; <strong>INCRBY x 100</strong>
(integer) 101
127.0.0.1:6379&gt; <strong>get x</strong>
"101"
127.0.0.1:6379&gt; <strong>DECR x</strong>
(integer) 100
127.0.0.1:6379&gt; <strong>get x</strong>
"100"
</pre>

<p><div class="rs-tip-major">Proč vlastně tyto příkazy existují? Díky jejich
existenci nemusíme zvýšení či snížení hodnoty řešit v&nbsp;transakci. Transakce
lze samozřejmě použít, ale není nutné s&nbsp;nimi &bdquo;plýtvat&ldquo; na
takto jednoduchou věc.</div></p>

<p>Podobná operace nazvaná <strong>INCRBYFLOAT</strong> slouží pro změnu
hodnoty čísla s&nbsp;desetinnou tečkou (opět ovšem uloženého formou běžného
řetězce). Příklad na interpretaci řetězce jako čísla s&nbsp;plovoucí řádovou
čárkou:</p>

<pre>
127.0.0.1:6379&gt; <strong>set y 0.5</strong>
OK
127.0.0.1:6379&gt; <strong>INCRBYFLOAT y 0.3</strong>
"0.8"
127.0.0.1:6379&gt; <strong>get y</strong>
"0.8"
</pre>

<p>Řetězec &bdquo;0.8&ldquo; ovšem již není možné považovat za reprezentaci
celého čísla:</p>

<pre>
127.0.0.1:6379&gt; <strong>incr y</strong>
(error) ERR value is not an integer or out of range
</pre>

<p><div class="rs-tip-major">Poznámka: hodnoty uložené pod klíči
&bdquo;x&ldquo;, &bdquo;y&ldquo; a &bdquo;z&ldquo; ve skutečnosti stále
zůstávají řetězci:</div></p>

<pre>
127.0.0.1:6379&gt; <strong>type x</strong>
string
127.0.0.1:6379&gt; <strong>type y</strong>
string
127.0.0.1:6379&gt; <strong>type z</strong>
string
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Seznamy</h2>

<p>Dalším datovým typem, který se v&nbsp;Redisu velmi často používá, jsou
seznamy (<i>list</i>). Tento název je ovšem poněkud nepřesný, protože seznamy
je možné využít například i pro implementaci fronty (<i>queue</i>), zásobníku
(<i>stack</i>), běžného pole (<i>array</i>) nebo dokonce obousměrné fronty
(<i>deque</i>). Počet prvků zapisovaných do seznamu může dosahovat prakticky
neomezené hodnoty, konkrétně lze do jediného seznamu uložit 2<sup>32</sup>-1
prvků. Mezi základní operace pro práci se seznamy patří:</p>

<table>
<tr><th>Příkaz</th><th>Význam</th></tr>
<tr><td>lpush</td><td>přidání prvku na začátek seznamu</td></tr>
<tr><td>rpush</td><td>přidání prvku na konec seznamu</td></tr>
<tr><td>lpop</td><td>přečtení prvního prvku ze seznamu s&nbsp;jeho odstraněním</td></tr>
<tr><td>rpop</td><td>přečtení posledního prvku ze seznamu s&nbsp;jeho odstraněním</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>lset</td><td>změna hodnoty prvku na určeném indexu v&nbsp;seznamu</td></tr>
<tr><td>lindex</td><td>přečtení prvku se zadaným indexem</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>linsert</td><td>přidání prvku na určený index seznamu (s&nbsp;posunem dalších prvků)</td></tr>
<tr><td>llen</td><td>přečtení délky seznamu</td></tr>
</table>

<p>Podívejme se nyní na několik příkladů. Seznam uložený pod klíčem
&bdquo;l&ldquo; se automaticky vytvoří hned prvním příkazem:</p>

<pre>
127.0.0.1:6379&gt; <strong>lpush l 3</strong>
(integer) 1
127.0.0.1:6379&gt; <strong>lpush l 2</strong>
(integer) 2
127.0.0.1:6379&gt; <strong>lpush l 1</strong>
(integer) 3
127.0.0.1:6379&gt; <strong>llen l</strong>
(integer) 3
127.0.0.1:6379&gt; <strong>rpush l 1</strong>
(integer) 4
127.0.0.1:6379&gt; <strong>rpush l 2</strong>
(integer) 5
127.0.0.1:6379&gt; <strong>rpush l 3</strong>
(integer) 6
127.0.0.1:6379&gt; <strong>llen l</strong>
(integer) 6
</pre>

<p>Typ hodnoty uložené pod klíčem &bdquo;l&ldquo;:</p>

<pre>
127.0.0.1:6379&gt; <strong>type l</strong>
list
</pre>

<p>Seznam nelze přečíst operací <strong>get</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>get l</strong>
(error) WRONGTYPE Operation against a key holding the wrong kind of value
</pre>

<p>Čtení prvků ze začátku i konce seznamu s&nbsp;jejich postupným
odstraňováním:</p>

<pre>
127.0.0.1:6379&gt; <strong>lpop l</strong>
"1"
127.0.0.1:6379&gt; <strong>lpop l</strong>
"2"
127.0.0.1:6379&gt; <strong>lpop l</strong>
"3"
127.0.0.1:6379&gt; <strong>lpop l</strong>
"1"
127.0.0.1:6379&gt; <strong>lpop l</strong>
"2"
127.0.0.1:6379&gt; <strong>lpop l</strong>
"3"
</pre>

<p>Pokus o přečtení hodnoty z&nbsp;prázdného seznamu:</p>

<pre>
127.0.0.1:6379&gt; <strong>lpop l</strong>
(nil)
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Množiny</h2>

<p>Dalším datovým typem, s&nbsp;nímž je možné v&nbsp;Redisu pracovat, jsou
množiny. Každá množina může obsahovat až 2<sup>32</sup>-1 prvků, což je stejná
kapacita, jako u seznamů. Prvky se do množiny přidávají příkazem
<strong>sadd</strong>. Pokud množina neexistuje, je prvním příkazem
<strong>sadd</strong> vytvořena:</p>

<pre>
127.0.0.1:6379&gt; <strong>sadd s "foo"</strong>
(integer) 1
127.0.0.1:6379&gt; <strong>sadd s "bar"</strong>
(integer) 1
127.0.0.1:6379&gt; <strong>sadd s "baz"</strong>
(integer) 1
</pre>

<p>Počet prvků v&nbsp;množině získáme příkazem <strong>scard</strong>, seznam
všech prvků pak příkazem <strong>smembers</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>scard s</strong>
(integer) 3
&nbsp;
127.0.0.1:6379&gt; <strong>smembers s</strong>
1) "bar"
2) "baz"
3) "foo"
</pre>

<p>Test, jestli množina obsahuje nějaký prvek, zajistí příkaz
<strong>sismemer</strong>, který vrací numerickou hodnotu 0 nebo 1:</p>

<pre>
127.0.0.1:6379&gt; <strong>sismember s "foo"</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sismember s "xyzzy"</strong>
(integer) 0
</pre>

<p>Odstranění prvku z&nbsp;množiny zajistí příkaz <strong>srem</strong>, který
navíc vrátí příznak, zda byl prvek odstraněn (tj.&nbsp;zda vůbec v&nbsp;množině
figuroval):</p>

<pre>
127.0.0.1:6379&gt; <strong>srem s "foo"</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sismember s "foo"</strong>
(integer) 0
&nbsp;
127.0.0.1:6379&gt; <strong>smembers s</strong>
1) "bar"
2) "baz"
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Množinové operace</h2>

<p>Systém Redis podporuje provádění základních množinových operací &ndash;
sjednocení, průniku a rozdílu. Tyto operace jsou vyvolány příkazy
<strong>sunion</strong>, <strong>sunionstore</strong>, <strong>sinter</strong>,
<strong>sinterstore</strong>, <strong>sdiff</strong> a
<strong>sdiffstore</strong>.</p>

<p>Před ukázkou těchto operací si vytvoříme dvě množiny <strong>s1</strong> a
<strong>s2</strong>.</p>

<p>Naplnění množiny <strong>s1</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>sadd s1 1</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd s1 2</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd s1 3</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd s1 4</strong>
(integer) 1
</pre>

<p>Naplnění množiny <strong>s2</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>sadd s2 3</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd s2 4</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd s2 5</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd s2 6</strong>
(integer) 1
</pre>

<p>Obsah obou množin:</p>

<pre>
127.0.0.1:6379&gt; <strong>smembers s1</strong>
1) "1"
2) "2"
3) "3"
4) "4"
&nbsp;
127.0.0.1:6379&gt; <strong>smembers s2</strong>
1) "3"
2) "4"
3) "5"
4) "6"
</pre>

<p>Příkazem <strong>sunionstore</strong> vytvoříme novou množinu, která bude
sjednocením obou množin zdrojových:</p>

<pre>
127.0.0.1:6379&gt; <strong>sunionstore s3 s1 s2</strong>
(integer) 6
&nbsp;
127.0.0.1:6379&gt; <strong>smembers s3</strong>
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
</pre>

<p>Podobně je možné příkazem <strong>sinterstore</strong> vytvořit novou
množinu pomocí operace průniku:</p>

<pre>
127.0.0.1:6379&gt; <strong>sinterstore s4 s1 s2</strong>
(integer) 2
&nbsp;
127.0.0.1:6379&gt; <strong>smembers s4</strong>
1) "3"
2) "4"
</pre>

<p>Poslední podporovanou operací je rozdíl množin. Tato operace není
komutativní, takže je pochopitelně rozdíl mezi rozdílem s1\s2 a s2\s1:</p>

<pre>
127.0.0.1:6379&gt; <strong>sdiffstore s5 s1 s2</strong>
(integer) 2
&nbsp;
127.0.0.1:6379&gt; <strong>smembers s5</strong>
1) "1"
2) "2"
&nbsp;
127.0.0.1:6379&gt; <strong>sdiffstore s6 s2 s1</strong>
(integer) 2
&nbsp;
127.0.0.1:6379&gt; <strong>smembers s6</strong>
1) "5"
2) "6"
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Mapy (asociativní pole)</h2>

<p>Jedním z&nbsp;nejpoužívanějších datových typů v&nbsp;Redisu jsou mapy neboli
asociativní pole. Každá mapa může obsahovat 2<sup>32</sup>-1 dvojic
klíč-hodnota, přičemž klíčem jsou řetězce. Příkazy pro práci
s&nbsp;asociativními poli začínají prefixem &bdquo;H&ldquo;. Základním příkazem
je <strong>hset</strong> pro uložení dvojice klíč-hodnota do množiny, ovšem
častěji se setkáme s&nbsp;příkazem <strong>hmset</strong>, který umožňuje
uložit větší množství dvojic jedinou operací. Opakem jsou operace
<strong>hget</strong> pro přečtení jednoho prvku nebo <strong>hgetall</strong>
pro přečtení všech dvojic (formou tabulky, tj.&nbsp;tabulka má dvakrát více
prvků, než asociativní pole):</p>

<pre>
127.0.0.1:6379&gt; <strong>hset apole x 1</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>hset apole y 2</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>hget apole x</strong>
"1"
&nbsp;
127.0.0.1:6379&gt; <strong>hget apole z</strong>
(nil)
</pre>

<p>Přepis existující hodnoty:</p>

<pre>
127.0.0.1:6379&gt; <strong>hset apole x "nova hodnota"</strong>
(integer) 0
&nbsp;
127.0.0.1:6379&gt; <strong>hget apole x </strong>
"nova hodnota"
</pre>

<p>Použití příkazů <strong>hmset</strong> a <strong>hgetall</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>hmset user:1000 username antirez password P1pp0 age 34</strong>
OK
&nbsp;
127.0.0.1:6379&gt; <strong>hgetall user:1000</strong>
1) "username"
2) "antirez"
3) "password"
4) "P1pp0"
5) "age"
6) "34"
&nbsp;
127.0.0.1:6379&gt; <strong>hset user:1000 password 12345</strong>
(integer) 0
&nbsp;
127.0.0.1:6379&gt; <strong>hgetall user:1000</strong>
1) "username"
2) "antirez"
3) "password"
4) "12345"
5) "age"
6) "34"
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Množiny s&nbsp;ohodnocenými prvky (uspořádané množiny)</h2>

<p>Posledním datovým typem Redisu, o kterém se dnes zmíníme, jsou množiny
s&nbsp;ohodnocenými prvky. Každému prvku je přiřazeno číslo, které je následně
použito při porovnávání jednotlivých prvků (množina je tedy částečně
uspořádaná), při zpětném čtení prvků apod. Příkazy, které s&nbsp;tímto datovým
typem pracují, začínají prefixem &bdquo;z&ldquo;. Nejprve vytvoříme novou
množinu a přidáme do ní několik prvků. Zadané číslo odpovídá ohodnocení
prvků:</p>

<pre>
127.0.0.1:6379&gt; <strong>zadd set 100 x</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>zadd set 150 y</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>zadd set 50 z</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>zadd set -5 w</strong>
(integer) 1
</pre>

<p>Hodnota ve skutečnosti může být reálné číslo, nikoli pouze číslo celé:</p>

<pre>
127.0.0.1:6379&gt; <strong>zadd set 0.5 a</strong>
(integer) 1
</pre>

<p>Aktuální pořadí prvku (na základě jeho ohodnocení) přečteme příkazem
<strong>zrank</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>zrank set x</strong>
(integer) 3
&nbsp;
127.0.0.1:6379&gt; <strong>zrank set w</strong>
(integer) 0
&nbsp;
127.0.0.1:6379&gt; <strong>zrank set foo</strong>
(nil)
</pre>

<p>Dále můžeme získat počet prvků množiny příkazem <strong>zcard</strong>,
popř.&nbsp;příkazem <strong>zcount</strong> zjistit počet takových prvků,
jejichž skóre leží v&nbsp;nějakém zadaném intervalu:</p>

<pre>
127.0.0.1:6379&gt; <strong>zcard set</strong>
(integer) 4
&nbsp;
127.0.0.1:6379&gt; <strong>zcount set -1000 1000</strong>
(integer) 4
&nbsp;
127.0.0.1:6379&gt; <strong>zcount set 0 1000</strong>
(integer) 3
</pre>

<p>Ohodnocení lze změnit příkazem <strong>zincrby</strong>, kterému se zadá
relativní přírůstek (samozřejmě může být i záporný):</p>

<pre>
127.0.0.1:6379&gt; <strong>zrank set x</strong>
(integer) 3
&nbsp;
127.0.0.1:6379&gt; <strong>zincrby set 1000 x</strong>
"1100"
&nbsp;
127.0.0.1:6379&gt; <strong>zrank set x</strong>
(integer) 4
&nbsp;
127.0.0.1:6379&gt; <strong>zincrby set -2000 x</strong>
"-900"
&nbsp;
127.0.0.1:6379&gt; <strong>zrank set x</strong>
(integer) 0
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Další operace s&nbsp;uspořádanými množinami</h2>

<p>Nad uspořádanými množinami je možné provádět i další operace, například
získat ty prvky, jejichž ohodnocení se nachází mezi specifikovanými mezními
hodnotami:</p>

<pre>
127.0.0.1:6379&gt; <strong>zrangebyscore set 1 200</strong>
1) "z"
2) "y"
&nbsp;
127.0.0.1:6379&gt; <strong>zrangebyscore set 1 300</strong>
1) "z"
2) "y"
3) "x"
</pre>

<p>Příkazem <strong>zremrangebyscore</strong> lze odstranit prvky, jejichž
ohodnocení (skóre) se nachází mezi mezními hodnotami:</p>

<pre>
127.0.0.1:6379&gt; <strong>zremrangebyscore set 1 200</strong>
(integer) 2
&nbsp;
127.0.0.1:6379&gt; <strong>zrangebyscore set -1000 1000</strong>
1) "w"
2) "x"
</pre>

<p>Pokus o vymazání prvků se skóre, které v&nbsp;množině neleží:</p>

<pre>
127.0.0.1:6379&gt; <strong>zrangebyscore set 1 200</strong>
(empty list or set)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Transakce</h2>

<p>Redis taktéž podporuje transakce. U příkazů, které jsou součástí transakce,
jsou dodrženy následující podmínky:</p>

<ol>

<li>Všechny příkazy v&nbsp;transakci jsou provedeny v&nbsp;takovém pořadí,
v&nbsp;jakém jsou zapsány uživatelem.</li>

<li>Mezi tyto příkazy se nikdy nevmísí příkazy vyžadované jiným klientem.</li>

<li>Transakce je atomická: buď se provede celá (všechny příkazy), nebo se
neprovede vůbec.</li>

</ol>

<p>Pro práci s&nbsp;transakcemi jsou určeny příkazy <strong>multi</strong>,
<strong>exec</strong> a <strong>discard</strong>. Podívejme se nyní na velmi
jednoduchý &bdquo;školní&ldquo; příklad, v&nbsp;němž se převádí nějaká částka
mezi dvěma účty &bdquo;ucet1&ldquo; a &bdquo;ucet2&ldquo;:</p>

<pre>
127.0.0.1:6379&gt; <strong>set ucet1 1000.0</strong>
OK
&nbsp;
127.0.0.1:6379&gt; <strong>set ucet2 0.0</strong>
OK
</pre>

<p>Tuto peněžní transakci musíme provést v&nbsp;databázové transakci,
tj.&nbsp;zadáme ji mezi příkazy <strong>multi</strong> a
<strong>exec</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>multi</strong>
OK
127.0.0.1:6379&gt; <strong>incrbyfloat ucet1 -150.50</strong>
QUEUED
127.0.0.1:6379&gt; <strong>incrbyfloat ucet2 +150.50</strong>
QUEUED
127.0.0.1:6379&gt; <strong>exec</strong>
1) "849.5"
2) "150.5"
</pre>

<p>Výsledné hodnoty na účtu po provedení transakce:</p>

<pre>
127.0.0.1:6379&gt; <strong>get ucet1</strong>
"849.5"
127.0.0.1:6379&gt; <strong>get ucet2</strong>
"150.5"
</pre>

<p><div class="rs-tip-major">Upozornění: v&nbsp;současné verzi Redisu není
možné transakce vnořovat:</div></p>

<pre>
127.0.0.1:6379&gt; <strong>multi</strong>
OK
&nbsp;
127.0.0.1:6379&gt; <strong>multi</strong>
(error) ERR MULTI calls can not be nested
</pre>

<p>Redis navíc neumožňuje ani rollback v&nbsp;případě, že při zpracování
transakce dojde k&nbsp;chybě nějakého příkazu.</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je práce
s&nbsp;transakcemi v&nbsp;Redisu ještě složitější, neboť je nutné sledovat
výsledek (zda transakce proběhla či nikoli) a v&nbsp;případě neúspěchu se
transakci pokusit provést znovu. S&nbsp;podrobnostmi se seznámíme
příště.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Použití Redisu z&nbsp;Pythonu</h2>

<p>Ve druhé části dnešního článku si ukážeme, jakým způsobem lze používat
databázi Redis z&nbsp;programovacího jazyka Python. Pro Redis samozřejmě
existuje knihovna (přesněji řečeno dokonce více knihoven) s&nbsp;rozhraním
k&nbsp;Redisu, které je &ndash; alespoň při použití běžných datových typů
&ndash; velmi jednoduše použitelné. Nejprve samozřejmě musíme příslušnou
knihovnu nainstalovat, což je otázka několika sekund. Postačuje použít příkaz
<strong>pip</strong> popř.&nbsp;<strong>pip3</strong> pro instalaci knihovny
<strong>redis</strong>. Pro jistotu instalaci provedeme pouze pro aktivního
uživatele, takže se knihovna i její metadata uloží do adresáře
<strong>~/.local/lib/python{VERZE}/site-packages/</strong>:</p>

<pre>
$ <strong>pip3 install --user redis</strong>
&nbsp;
Collecting redis
  Downloading https://files.pythonhosted.org/packages/3b/f6/7a76333cf0b9251ecf49efff635015171843d9b977e4ffcf59f9c4428052/redis-2.10.6-py2.py3-n
    100% |████████████████████████████████| 71kB 909kB/s
Installing collected packages: redis
Successfully installed redis-2.10.6
</pre>

<p>Pokud instalace knihovny <strong>redis</strong> proběhla v&nbsp;pořádku,
můžeme si ji vyzkoušet. Nejprve spustíme interaktivní smyčku Pythonu:</p>

<pre>
$ <strong>python3</strong>
Python 3.6.3 (default, Oct  9 2017, 12:11:29) 
[GCC 7.2.1 20170915 (Red Hat 7.2.1-2)] on linux
Type "help", "copyright", "credits" or "license" for more information.
</pre>

<p><div class="rs-tip-major">Poznámka: jak jste si mohli všimnout, testování
provádím na stroji s&nbsp;dnes již zastaralým systémem a taktéž postarší verzí
Pythonu. Ovšem knihovna <strong>redis</strong> je pochopitelně funkční i
s&nbsp;nejnovějším (stabilním) Pythonem 3.7.1.</div></p>

<p>V&nbsp;interpretru Pythonu nyní nejprve naimportujeme modul
<strong>redis</strong>.</p>

<pre>
&gt;&gt;&gt; import redis
</pre>

<p>Můžeme si vyzkoušet zobrazit si nápovědu:</p>

<pre>
&gt;&gt;&gt; help("redis")
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
Help on package redis:
&nbsp;
NAME
    redis
&nbsp;
PACKAGE CONTENTS
    _compat
    client
    connection
    exceptions
    lock
    sentinel
    utils
&nbsp;
CLASSES
    builtins.Exception(builtins.BaseException)
        redis.exceptions.RedisError
            redis.exceptions.AuthenticationError
            redis.exceptions.ConnectionError
                redis.exceptions.BusyLoadingError
</pre>

<p>Ovšem důležitější je samozřejmě vlastní rozhraní k&nbsp;databázi Redisu.
Nejprve vytvoříme objekt typu <strong>Redis</strong> zavoláním stejnojmenné
funkce, které se předá adresa a port Redis serveru, na který se klient pokusí
připojit. Náš server naslouchá na loopbacku, konkrétně na portu 6379:</p>

<pre>
&gt;&gt;&gt; r = redis.Redis(host='127.0.0.1', port=6379)
&gt;&gt;&gt; r
Redis&lt;ConnectionPool&lt;Connection&lt;host=127.0.0.1,port=6379,db=0&gt;&gt;&gt;
</pre>

<p>V&nbsp;případě, že se připojení podařilo, můžeme se pokusit přečíst
z&nbsp;databáze hodnotu uloženou pod klíčem &bdquo;answer&ldquo;. To je
jednoduché, protože postačuje použít metodu <strong>get()</strong>:</p>

<pre>
&gt;&gt;&gt; r.get("answer")
b'42'
&nbsp;
&gt;&gt;&gt; print(r.get("answer"))
b'42'
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si prefixu &bdquo;b&ldquo;
před řetězcem. Samotnou interpretaci jednotlivých bajtů můžete provést
programově.</div></p>

<p>V&nbsp;případě, že se pokusíme přečíst hodnotu pod neexistujícím klíčem,
vrátí se <strong>None</strong>:</p>

<pre>
&gt;&gt;&gt; r.get("foo")
&nbsp;
&gt;&gt;&gt; print(r.get("foobarbaz"))
None
</pre>

<p>Samozřejmě je možné do databáze i zapisovat, a to v&nbsp;tom nejjednodušším
případě metodou <strong>set</strong>:</p>

<pre>
&gt;&gt;&gt; r.set("foo", -1)
True
&gt;&gt;&gt; r.get("foo")
b'-1'
</pre>

<p>Zjištění délky seznamu:</p>

<pre>
&gt;&gt;&gt; r.llen("l")
1
</pre>

<p>Další příkazy si popíšeme v&nbsp;navazujícím textu.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Vybrané operace poskytované knihovnou <strong>redis</strong></h2>

<p>Vyzkoušejme si nyní některé další operace, které jsou poskytovány knihovnou
<strong>redis</strong> a které jsou tedy přístupné všem uživatelům Pythonu.</p>

<p>Nejprve si ukážeme nastavení řetězcové hodnoty a její modifikaci připojením
dalšího řetězce:</p>

<pre>
&gt;&gt;&gt; r.set("greeting", "")
True
&nbsp;
&gt;&gt;&gt; r.append("greeting", "Hello")
5
&nbsp;
&gt;&gt;&gt; r.append("greeting", " ")
6
&nbsp;
&gt;&gt;&gt; r.append("greeting", "world!")
12
&nbsp;
&gt;&gt;&gt; r.get("greeting")
b'Hello world!'
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se opět vrátil řetězec
obsahující sekvenci bajtů, jehož převod na &bdquo;skutečný&ldquo; řetězec je
již ponechán na programátorovi (ten pro tento účel může použít metodu
<strong>decode</strong>).</div></p>

<p>Nastavení řetězce a použití příkazů pro zvýšení a snížení numerické hodnoty
reprezentované řetězcem:</p>

<pre>
&gt;&gt;&gt; r.set("x", 10)
True
&gt;&gt;&gt; r.incr("x", 20)
30
&gt;&gt;&gt; r.get("x")
b'30'
&gt;&gt;&gt; r.decr("x", 1000)
-970
&gt;&gt;&gt; r.get("x")
b'-970'
</pre>

<p>Použití prvku nazvaného &bdquo;zasobnik&ldquo; ve funkci skutečného
zásobníku s&nbsp;operacemi <strong>PUSH</strong> a <strong>POP</strong>:</p>

<pre>
&gt;&gt;&gt; r.lpush("zasobnik", 1)
1
&nbsp;
&gt;&gt;&gt; r.lpush("zasobnik", 10)
2
&nbsp;
&gt;&gt;&gt; r.lpop("zasobnik")
b'10'
&nbsp;
&gt;&gt;&gt; r.lpop("zasobnik")
b'1'
&nbsp;
&gt;&gt;&gt; r.lpop("zasobnik")
&nbsp;
</pre>

<p>Použití prvku nazvaného &bdquo;fronta&ldquo; ve funkci jednosměrné fronty
s&nbsp;operacemi <strong>ENQUEUE</strong> a <strong>DEQUEUE</strong>
(realizovanými jinak pojmenovanými operacemi Redisu):</p>

<pre>
&gt;&gt;&gt; r.lpush("fronta", 1)
1
&nbsp;
&gt;&gt;&gt; r.lpush("fronta", 10)
2
&nbsp;
&gt;&gt;&gt; r.rpop("fronta")
b'1'
&nbsp;
&gt;&gt;&gt; r.rpop("fronta")
b'10'
&nbsp;
&gt;&gt;&gt; r.rpop("fronta")
&nbsp;
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Využití &bdquo;pipeline&ldquo; pro sloučení většího množství příkazů do jediného požadavku</h2>

<p>Velmi užitečný je v&nbsp;praxi objekt typu &bdquo;pipeline&ldquo;. Ten
umožňuje specifikovat větší množství příkazů, které se následně přenesou do
Redisu (na server) v&nbsp;jediném balíku. V&nbsp;praxi se totiž může ukázat, že
přenos jednotlivých příkazů je úzkým hrdlem celého systému. Nejprve si ukažme,
jakým způsobem se &bdquo;pipeline&ldquo; použije pouze pro seskupení příkazů,
nikoli pro provedení příkazů v&nbsp;transakci:</p>

<pre>
&gt;&gt;&gt; pipe = r.pipeline(transaction=False)
&nbsp;
&gt;&gt;&gt; for i in range(1, 11):
...     pipe.lpush("list1", i)
...     pipe.rpush("list2", i)
...
Pipeline&lt;ConnectionPool&lt;Connection&lt;host=127.0.0.1,port=6379,db=0&gt;&gt;&gt;
...
...
...
&nbsp;
&gt;&gt;&gt; pipe.execute()
[1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10]
</pre>

<p>Povšimněte si, že objekt typu <strong>pipeline</strong> nabízí stejné
metody, jako objekt typu <strong>Redis</strong>. Teprve po spuštění metody
<strong>pipe.execute()</strong> se všechny operace (v&nbsp;našem případě dvacet
operací <strong>PUSH</strong> přenesou na server a tam provedou. Server odpoví
seznamem výsledků těchto příkazů (tento seznam jen vypíšeme, ale jinak ho
můžeme ignorovat).</p>

<p>Test, zda se skutečně změnil obsah objektů pod klíči <strong>list1</strong>
a <strong>list2</strong>:</p>

<pre>
&gt;&gt;&gt; while True:
...     item = r.lpop("list1")
...     if item is None:
...         break
...     print(item)
... 
&nbsp;
b'10'
b'9'
b'8'
b'7'
b'6'
b'5'
b'4'
b'3'
b'2'
b'1'
</pre>

<pre>
&gt;&gt;&gt; while True:
...     item = r.lpop("list2")
...     if item is None:
...         break
...     print(item)
... 
&nbsp;
b'1'
b'2'
b'3'
b'4'
b'5'
b'6'
b'7'
b'8'
b'9'
b'10'
</pre>

<p><div class="rs-tip-major">Poznámka: použití smyčky <strong>while</strong> je
v&nbsp;Pythonu skutečně poněkud nepřirozené; zde jsem ji využil jen kvůli
jednoznačnosti zápisu.</div></p>

<p>Objekt typu <i>pipeline</i> je ovšem možné použít i pro provedení transakce.
Podívejme se na prozatím velmi jednoduchou transakci, která odpovídá
demonstračnímu příkladu, s&nbsp;nímž jsme se seznámili <a
href="#k16">v&nbsp;šestnácté kapitole</a> (jednalo se o převod peněžní částky
mezi dvěma účty):</p>

<pre>
&gt;&gt;&gt; r.set("ucet1", 1000.0)
True
&nbsp;
&gt;&gt;&gt; r.set("ucet2", 0.0)
True
&nbsp;
&gt;&gt;&gt; pipe = r.pipeline(transaction=True)
&nbsp;
&gt;&gt;&gt; pipe.incrbyfloat("ucet1", -150.50)
Pipeline&lt;ConnectionPool&lt;Connection&lt;host=127.0.0.1,port=6379,db=0&gt;&gt;&gt;
&nbsp;
&gt;&gt;&gt; pipe.incrbyfloat("ucet2", 150.50)
Pipeline&lt;ConnectionPool&lt;Connection&lt;host=127.0.0.1,port=6379,db=0&gt;&gt;&gt;
&nbsp;
&gt;&gt;&gt; pipe.execute()
[849.5, 150.5]
&nbsp;
&gt;&gt;&gt; r.get("ucet1")
b'849.5'
&nbsp;
&gt;&gt;&gt; r.get("ucet2")
b'150.5'
</pre>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

